
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#include "CrossSeq2.h"

void CrossSeq2__ctx_type_0_init(CrossSeq2__ctx_type_0 &_output_){
   CrossSeq2__ctx_type_0 _ctx;
   _ctx.x4 = 0.0f;
   _ctx.x3 = 0.0f;
   _ctx.x2 = 0.0f;
   _output_ = _ctx;
   return ;
}

float CrossSeq2_soft(CrossSeq2__ctx_type_0 &_ctx, float x1){
   float o;
   o = (0.25f * (_ctx.x2 + _ctx.x3 + _ctx.x4 + x1));
   float _tmp_1_0;
   _tmp_1_0 = x1;
   float _tmp_1_1;
   _tmp_1_1 = _ctx.x2;
   float _tmp_1_2;
   _tmp_1_2 = _ctx.x3;
   _ctx.x2 = _tmp_1_0;
   _ctx.x3 = _tmp_1_1;
   _ctx.x4 = _tmp_1_2;
   return o;
}

void CrossSeq2__ctx_type_4_init(CrossSeq2__ctx_type_4 &_output_){
   CrossSeq2__ctx_type_4 _ctx;
   _ctx.rate = 0.0f;
   _ctx.phase = 0.0f;
   CrossSeq2__ctx_type_0_init(_ctx._inst59);
   CrossSeq2__ctx_type_1_init(_ctx._inst35d);
   CrossSeq2__ctx_type_2_init(_ctx._inst193);
   _output_ = _ctx;
   return ;
}

float CrossSeq2_lfo_interp(CrossSeq2__ctx_type_4 &_ctx, float cv, float shape, float amt, float pw, float reset, float sampleTime){
   if(CrossSeq2_change(_ctx._inst193,cv)){
      _ctx.rate = (cv * sampleTime);
   }
   _ctx.phase = (_ctx.phase + _ctx.rate);
   if(_ctx.phase > 2.f){
      _ctx.phase = (-2.f + _ctx.phase);
   }
   uint8_t breset;
   breset = (reset > 0.0f);
   if(CrossSeq2_edge(_ctx._inst35d,breset)){
      _ctx.phase = 0.0f;
   }
   float tmp;
   tmp = (-1.f + _ctx.phase);
   float o;
   if(shape < 1.f){
      o = (amt * CrossSeq2_lerp(sinf((3.14159265359f * _ctx.phase)),(-1.f + (2.f * fabsf(tmp))),fmodf(shape,1.f)));
   }
   else
   {
      if(shape < 2.f){
         o = (amt * CrossSeq2_lerp((-1.f + (2.f * fabsf(tmp))),tmp,fmodf(shape,1.f)));
      }
      else
      {
         if(shape < 3.f){
            o = (amt * CrossSeq2_lerp(tmp,((tmp > 0.0f)?1.f:-1.f),fmodf(shape,1.f)));
         }
         else
         {
            o = (amt * ((tmp > pw)?1.f:-1.f));
         }
      }
   }
   return CrossSeq2_soft(_ctx._inst59,o);
}

float CrossSeq2_cross_detect(CrossSeq2__ctx_type_5 &_ctx, float a, float b){
   float diff;
   diff = (a + (- b));
   float sign;
   if(diff > 0.0f){
      sign = 1.f;
   }
   else
   {
      sign = 0.0f;
   }
   float trig;
   if(CrossSeq2_change(_ctx._inst193,sign)){
      trig = 1.f;
   }
   else
   {
      trig = 0.0f;
   }
   return trig;
}

void CrossSeq2__ctx_type_6_init(CrossSeq2__ctx_type_6 &_output_){
   CrossSeq2__ctx_type_6 _ctx;
   _ctx.sync = 0.0f;
   _ctx.shape2 = 0.0f;
   _ctx.shape1 = 0.0f;
   _ctx.rate2 = 0.0f;
   _ctx.rate1 = 0.0f;
   _ctx.pw2 = 0.0f;
   _ctx.pw1 = 0.0f;
   _ctx.process_ret_3 = 0.0f;
   _ctx.process_ret_2 = 0.0f;
   _ctx.process_ret_1 = 0.0f;
   _ctx.process_ret_0 = 0.0f;
   _ctx.phase1 = 0.0f;
   _ctx.freqK = 0.0f;
   _ctx.freq = 0.0f;
   _ctx.amt2 = 0.0f;
   _ctx.amt1 = 0.0f;
   CrossSeq2__ctx_type_5_init(_ctx._inst36b);
   CrossSeq2__ctx_type_4_init(_ctx._inst27f);
   CrossSeq2__ctx_type_4_init(_ctx._inst17f);
   _output_ = _ctx;
   return ;
}

void CrossSeq2_process(CrossSeq2__ctx_type_6 &_ctx, float sampleTime){
   float lfo1;
   lfo1 = CrossSeq2_lfo_interp(_ctx._inst17f,(_ctx.freq * _ctx.rate1),_ctx.shape1,_ctx.amt1,_ctx.pw1,_ctx.sync,sampleTime);
   float lfo2;
   lfo2 = CrossSeq2_lfo_interp(_ctx._inst27f,(_ctx.freq * _ctx.rate2),_ctx.shape2,_ctx.amt2,_ctx.pw2,_ctx.sync,sampleTime);
   float gate;
   gate = CrossSeq2_cross_detect(_ctx._inst36b,lfo1,lfo2);
   float trig;
   trig = gate;
   float diff;
   diff = (lfo1 + (- lfo2));
   _ctx.process_ret_0 = trig;
   _ctx.process_ret_1 = lfo1;
   _ctx.process_ret_2 = lfo2;
   _ctx.process_ret_3 = diff;
   return ;
}

void CrossSeq2_default(CrossSeq2__ctx_type_6 &_ctx){
   _ctx.freqK = 1.f;
   _ctx.sync = 0.0f;
   _ctx.rate1 = 1.f;
   _ctx.rate2 = 1.f;
   _ctx.amt1 = 1.f;
   _ctx.amt2 = 1.f;
   _ctx.shape1 = 0.0f;
   _ctx.shape2 = 1.f;
   _ctx.phase1 = 0.0f;
   _ctx.phase1 = 0.0f;
   _ctx.pw1 = 0.5f;
   _ctx.pw2 = 0.5f;
}


