
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#include "TrigLogic.h"

void TrigLogic__ctx_type_2_init(TrigLogic__ctx_type_2 &_output_){
   TrigLogic__ctx_type_2 _ctx;
   TrigLogic__ctx_type_0_init(_ctx._inst2b9);
   TrigLogic__ctx_type_0_init(_ctx._inst1b9);
   _output_ = _ctx;
   return ;
}

uint8_t TrigLogic_logic(TrigLogic__ctx_type_2 &_ctx, float x1, float x2, uint8_t type1, uint8_t type2, uint8_t s1, uint8_t s2, uint8_t andOr){
   uint8_t res1;
   uint8_t res2;
   if(type1){
      res1 = TrigLogic_direction(_ctx._inst1b9,x1);
   }
   else
   {
      res1 = TrigLogic_sign(x1);
   }
   if(type2){
      res2 = TrigLogic_direction(_ctx._inst2b9,x2);
   }
   else
   {
      res2 = TrigLogic_sign(x2);
   }
   if(bool_not(s1)){
      res1 = bool_not(res1);
   }
   if(bool_not(s2)){
      res2 = bool_not(res2);
   }
   uint8_t ret;
   if(andOr){
      ret = (res1 && res2);
   }
   else
   {
      ret = (res1 || res2);
   }
   return ret;
}

void TrigLogic__ctx_type_3_init(TrigLogic__ctx_type_3 &_output_){
   TrigLogic__ctx_type_3 _ctx;
   _ctx.type2 = false;
   _ctx.type1 = false;
   _ctx.s2 = false;
   _ctx.s1 = false;
   _ctx.process_ret_1 = 0.0f;
   _ctx.process_ret_0 = 0.0f;
   _ctx.inv = false;
   _ctx.andOr = false;
   TrigLogic__ctx_type_2_init(_ctx._inst129);
   _output_ = _ctx;
   return ;
}

void TrigLogic_process(TrigLogic__ctx_type_3 &_ctx, float trig, float lfo1, float lfo2){
   uint8_t l;
   l = TrigLogic_logic(_ctx._inst129,lfo1,lfo2,_ctx.type1,_ctx.type2,_ctx.s1,_ctx.s2,_ctx.andOr);
   float ret1;
   if(l){
      ret1 = trig;
   }
   else
   {
      ret1 = 0.0f;
   }
   float ret2;
   if(bool_not(l)){
      ret2 = trig;
   }
   else
   {
      ret2 = 0.0f;
   }
   _ctx.process_ret_0 = ret1;
   _ctx.process_ret_1 = ret2;
   return ;
}

void TrigLogic_default(TrigLogic__ctx_type_3 &_ctx){
   _ctx.type1 = true;
   _ctx.type2 = true;
   _ctx.s1 = true;
   _ctx.s2 = true;
   _ctx.andOr = true;
   _ctx.inv = false;
}


